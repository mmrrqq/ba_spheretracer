#version 410 core
#define MAX_OBJECTS 10
#define MAX_MATERIALS 5
#define MAX_LIGHTS 5
struct PointLight
{
    vec3 position;
    vec3 color;
    float size;
};

struct Sphere 
{
    int materialId;
    vec3 position;
    float radius;
    bool morph;
};

struct Torus
{
    int materialId;
    vec3 position;
    float radius;
    float tubeRadius;
};

struct Material
{
    vec3 ambientColor;    
    vec3 diffuseColor;
    vec3 specularColor;
    float shininess;
};

struct PrimitiveScene 
{
    Sphere spheres[MAX_OBJECTS];
    Torus tori[MAX_OBJECTS];        
    int numSpheres;
    int numTori;
};

struct SceneLights
{
    PointLight pointLights[MAX_LIGHTS];
    int numPointLights;
};

float distEpsilon = 0.01;
bool ortho = false;
bool showStepCount = false;

uniform float UFovY;
uniform vec2 UImageDim;
uniform float UNormalEpsilon;
uniform vec3 ULightDirection;
uniform vec4 UEyePosition;
uniform int UMarchingSteps;
uniform float UMaxDrawDistance;

uniform sampler2D UDepthTexture;

uniform PrimitiveScene UScene;
uniform SceneLights ULights;
uniform Material UMaterials[MAX_MATERIALS];
uniform mat4 UInvView;

in vec2 TexCoords;
out vec4 color;

// credit iquilez
float distanceToMandelbrot2(vec3 pos)
{
    vec3 w = pos;
    float m = dot(w,w);

    vec4 trap = vec4(abs(w),m);
	float dz = 1.0;
    
    
	for( int i=0; i<4; i++ )
    {
        float m2 = m*m;
        float m4 = m2*m2;
		dz = 8.0*sqrt(m4*m2*m)*dz + 1.0;

        float x = w.x; float x2 = x*x; float x4 = x2*x2;
        float y = w.y; float y2 = y*y; float y4 = y2*y2;
        float z = w.z; float z2 = z*z; float z4 = z2*z2;

        float k3 = x2 + z2;
        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );
        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;
        float k4 = x2 - y2 + z2;

        w.x = pos.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;
        w.y = pos.y + -16.0*y2*k3*k4*k4 + k1*k1;
        w.z = pos.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2; 
        
        trap = min( trap, vec4(abs(w),m) );

        m = dot(w,w);
		if( m > 256.0 )
            break;
    }    

    return 0.25*log(m)*sqrt(m)/dz;
}

float distanceToGroundPlane(vec3 planePosition, vec4 planeNormal, vec3 position)
{
	return dot(position - planePosition, planeNormal.xyz) + planeNormal.w;
}

float distanceToSphere(vec3 spherePosition, float sphereRadius, vec3 position)
{
    return length(position - spherePosition) - sphereRadius;
}

float distanceToTorus(vec3 torusPosition, float radius, float tubeRadius, vec3 position)
{
    vec3 torusToPosition = position - torusPosition;
    vec2 q = vec2(length(torusToPosition.xz)-radius,torusToPosition.y);
    return length(q)-tubeRadius;
}

vec4 hardMin(vec4 dist1, vec4 dist2)
{
    return dist1.x < dist2.x ? dist1 : dist2;
}

vec4 smoothMin(vec2 dist1, vec2 dist2, float k)
{
    vec2 minVec = mix(dist1, dist2, step(dist2.x, dist1.x));
    vec2 maxVec = mix(dist1, dist2, step(dist1.x, dist2.x));

    float h = max(k - abs(dist1.x - dist2.x), 0.0)/k;
    float dist = min(dist1.x, dist2.x) - h*h*k*(1.0/4.0);
    return vec4(dist, minVec.y, maxVec.y, h/2.0);
}

// -> vec2(distance, materialId)
vec4 distanceToScene(vec3 position) 
{
    vec4 res = vec4(1000, -1, -1, -1);

    for (int i = 0; i < UScene.numSpheres; i++)
    {
        Sphere sphere = UScene.spheres[i];
        float d = distanceToSphere(sphere.position, sphere.radius, position);        
        if (sphere.morph)
            res = smoothMin(res.xy, vec2(d, sphere.materialId), 0.5);
        else
            res = hardMin(res, vec4(d, sphere.materialId, -1, -1));
    }

    for (int i = 0; i < UScene.numTori; i++)
    {
        Torus torus = UScene.tori[i];
        float d = distanceToTorus(torus.position, torus.radius, torus.tubeRadius, position);
        res = hardMin(res, vec4(d, torus.materialId, -1, -1));             
    }

    float planeDistance = distanceToGroundPlane(vec3(0.0, -0.5, 0.0), vec4(0.0, 1.0, 0.0, 0.0), position);    
    res = hardMin(res, vec4(planeDistance, 0, -1, -1));

    return res;
}

// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
vec3 getRayDir()
{
    vec2 uv = tan(radians(UFovY)/2) * ((TexCoords * UImageDim + 0.5) - 0.5 * UImageDim) / UImageDim.y;        
    return  normalize(vec3(uv, -1));                
}

// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting
vec3 getNormal(vec3 position)
{
    vec2 epsilon = vec2(UNormalEpsilon, 0.0);

    return normalize(
        vec3(
            distanceToScene(position + epsilon.xyy).x - distanceToScene(position - epsilon.xyy).x,
            distanceToScene(position + epsilon.yxy).x - distanceToScene(position - epsilon.yxy).x,
            distanceToScene(position + epsilon.yyx).x - distanceToScene(position - epsilon.yyx).x
        )
    );
}

float getPointLightShadowFactor(vec3 position, vec3 lightPosition, float lightSize)
{
    vec3 lightVec = lightPosition - position;
    float maxDist = length(lightVec);    
    vec3 rayDir = normalize(lightVec); 
    float dist = 0.0;    
    float minDist = 1.0;
    float depth = 0.001;    

    for(int i = 0; i < UMarchingSteps; i++)
    {                        
        dist = distanceToScene(position + depth * rayDir).x;  
        // pad by 0.5 to improve inner shadow
        minDist = min(0.5 + 0.5 * dist/(depth*lightSize), minDist);              
        if (minDist < 0.01)                                  
            break;    

        // this line is important as I want to step INTO the objects to get a negative dist
        depth += clamp(dist, 0.005, 0.50);
        if (depth > maxDist)
            break;
    }        
    return max(minDist, 0.0);         
}

vec3 getPhongColor(vec3 position, vec3 normal, int firstMaterialID, int secondMaterialID, float matMix, vec4 rayDir)
{   
    Material material;
    if (secondMaterialID == -1)     
        material = UMaterials[firstMaterialID];    
    else
    {
        Material material1 = UMaterials[firstMaterialID];
        Material material2 = UMaterials[secondMaterialID];
        material.ambientColor = mix(material1.ambientColor, material2.ambientColor, matMix);
        material.diffuseColor = mix(material1.diffuseColor, material2.diffuseColor, matMix);
        material.specularColor = mix(material1.specularColor, material2.specularColor, matMix);
        material.shininess = mix(material1.shininess, material2.shininess, matMix);
    }
    
    vec3 phongColor = vec3(0.0, 0.0, 0.0);    
    
    for (int i = 0; i < ULights.numPointLights; i++)
    {
        PointLight light = ULights.pointLights[i];
        phongColor += material.ambientColor * light.color;
        vec3 lightDir = normalize(light.position - position);
        float diffuseContribution = dot(normal, lightDir);    
        float shadow = getPointLightShadowFactor(position, light.position, light.size);        

        if (shadow < 0.01 || diffuseContribution < 0.0)    
            continue;        
            
        vec3 reflected = reflect(lightDir, normal);
        float specularContribution = pow(max(dot(vec3(rayDir), reflected), 0.0), 32);
                
        phongColor += shadow * (diffuseContribution * material.diffuseColor * light.color
            + specularContribution * material.specularColor * light.color);

    }    
    return phongColor;
}

void main()
{
    vec3 cameraRayDir = getRayDir();
    vec4 rayDirection = UInvView * vec4(cameraRayDir, 0.0);       
    float dist = 0;
    
    vec3 position;
    vec4 eyePosition = UEyePosition;

    float depth = texture(UDepthTexture, TexCoords.xy).r * UMaxDrawDistance;    

    if (depth > UMaxDrawDistance - 1)
    {
        color = vec4(0.1, 0.1, 0.1, 1.0) * exp(-0.00005*depth*depth*depth);        
        return;
    }

    // https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer
    // Sphere tracing: a geometric method for the antialiased ray tracing of implicit surfaces, John C. Hart, 1996.
    float coneRadiusCoeff = 2 * tan(radians(UFovY/2))/ UImageDim.y;

    for(int i = 0; i < UMarchingSteps; i++)
    {                
        position = vec3(eyePosition + depth * rayDirection);        
        vec4 dist_mat = distanceToScene(position);
        dist = dist_mat.x; 
        float coneRadius = depth * coneRadiusCoeff;   
        if (dist < coneRadius)        
        {
            if (showStepCount)
            {
                float steps = i/float(UMarchingSteps);
                color = vec4(steps, 0.0, 1.0 - steps, 1.0);
            }
            else
            {
                color = vec4(getPhongColor(position, getNormal(position), int(dist_mat.y), int(dist_mat.z), dist_mat.w, rayDirection), 1.0) * exp(-0.00005*depth*depth*depth);
            }
            return;
        }                   

        depth += dist;

        if (depth > UMaxDrawDistance)
        {
            color = vec4(0.1, 0.1, 0.1, 1.0) * exp(-0.00005*depth*depth*depth);
            return;
        }

        // this creates a cool looking effect! but no distant fog as it was intended for :)
        // if (depth > UMaxDrawDistance - 10.0) 
        // {
        //     float factor = depth / UMaxDrawDistance;
        //     color = vec4(0.1, 0.1, 0.1, 1.0) * factor;
        //     return;
        // }
    }    
    color = vec4(0.1, 0.1, 0.1, 1.0) * exp(-0.00005*depth*depth*depth);
}