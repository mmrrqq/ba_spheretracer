#version 410 core

vec3 eyePosition = vec3(0.0, 0.0, 3.0);
float distEpsilon = 0.001;
int maxMarchingSteps = 100;
bool ortho = false;

uniform vec2 UImageDim;
uniform float UNormalEpsilon;
uniform vec3 ULightDirection;

in vec2 TexCoords;
out vec4 color;

float distanceToGroundPlane(vec3 planePosition, vec4 planeNormal, vec3 position)
{
	return dot(position - planePosition, planeNormal.xyz) + planeNormal.w;
}

float distanceToSphere(vec3 spherePosition, float sphereRadius, vec3 position)
{
    return length(position - spherePosition) - sphereRadius;
}

float distanceToTorus(vec3 torusPosition, float p1, float p2, vec3 position)
{
    vec3 torusToPosition = position - torusPosition;
    vec2 q = vec2(length(torusToPosition.xz)-p1,torusToPosition.y);
    return length(q)-p2;
}

float distanceToScene(vec3 position) 
{
    float minDistance;
    float currentDistance;
    // scene defined here
    minDistance = distanceToSphere(vec3(0.0, 0.0, -5.0), 1.0, position);

    minDistance = min(minDistance, distanceToTorus(vec3(-2.0, 0.0, -5.0), 0.3, 0.2, position));

    minDistance = min(minDistance, distanceToGroundPlane(vec3(0.0, -2.0, 0.0), normalize(vec4(0.0, 1.0, 0.0, 0.0)), position));

    return minDistance;
}

// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
vec3 getRayDirection()
{          
    vec2 uv = ((TexCoords * UImageDim + 0.5) - 0.5 * UImageDim) / UImageDim.y;    
    return normalize(vec3(uv, -1));
}

// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting
vec3 getNormal(vec3 position)
{
    vec2 epsilon = vec2(UNormalEpsilon, 0.0);

    return normalize(
        vec3(
            distanceToScene(position + epsilon.xyy) - distanceToScene(position - epsilon.xyy),
            distanceToScene(position + epsilon.yxy) - distanceToScene(position - epsilon.yxy),
            distanceToScene(position + epsilon.yyx) - distanceToScene(position - epsilon.yyx)
        )
    );
}

vec3 getPhongColor(vec3 position, vec3 normal)
{
    // TODO: move to material struct
    float materialDiffuse = 0.7;
    float materialAmbient = 0.2;
    // TODO: move to light struct
    vec3 lightColor = vec3(1.0, 0.9, 0.9);
        
    float diffuseContribution = dot(normal, - ULightDirection);

    // TODO: add specular
    return materialAmbient * lightColor + diffuseContribution * materialDiffuse * lightColor;
}

void main()
{
    vec3 rayDirection = getRayDirection();
    float dist = 0;
    float depth = 0;
    vec3 position;    

    if (ortho)
    {
        eyePosition += vec3(((TexCoords * UImageDim + 0.5) - 0.5 * UImageDim) / UImageDim.y, 0.0);
        rayDirection = vec3(0,0,-1);
    }

    for(int i = 0; i < maxMarchingSteps; i++)
    {                
        position = eyePosition + depth * rayDirection;        
        dist = distanceToScene(position);
        if (dist < distEpsilon)
        {
            color = vec4(getPhongColor(position, getNormal(position)), 1.0);
            return;
        }           
        depth += dist;
    }    
    color = vec4(0.1, 0.1, 0.1, 1.0);
}