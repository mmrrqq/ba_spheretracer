#version 410 core
#define MAX_OBJECTS 10
#define MAX_MATERIALS 5
struct Sphere 
{
    int materialId;
    vec3 position;
    float radius;
};

struct Torus
{
    int materialId;
    vec3 position;
    float radius;
    float tubeRadius;
};

struct Material
{
    vec3 ambientColor;    
    vec3 diffuseColor;
    vec3 specularColor;
    float shininess;
};

struct PrimitiveScene 
{
    Sphere spheres[MAX_OBJECTS];
    Torus tori[MAX_OBJECTS];    
    int numSpheres;
    int numTori;
};

float distEpsilon = 0.001;
int maxMarchingSteps = 128;
float maxDrawDistance = 50.0;
bool ortho = false;
bool showStepCount = false;

uniform vec2 UImageDim;
uniform float UNormalEpsilon;
uniform vec3 ULightDirection;
uniform vec4 UEyePosition;

uniform PrimitiveScene UScene;
uniform Material UMaterials[MAX_MATERIALS];
uniform mat4 UInvView;

in vec2 TexCoords;
out vec4 color;

//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/
float distanceToMandelbrot(vec3 pos) 
{
	vec3 z = pos;
    float power = 10;
	float dr = 1.0;
	float r = 0.0;
	for (int i = 0; i < 15 ; i++) {
		r = length(z);
		if (r>2) break;
		
		// convert to polar coordinates
		float theta = acos(z.z/r);
		float phi = atan(z.y,z.x);
		dr =  pow( r, power-1.0)*power*dr + 1.0;
		
		// scale and rotate the point
		float zr = pow( r,power);
		theta = theta*power;
		phi = phi*power;
		
		// convert back to cartesian coordinates
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=pos;
	}
	return 0.5*log(r)*r/dr;
}

float distanceToGroundPlane(vec3 planePosition, vec4 planeNormal, vec3 position)
{
	return dot(position - planePosition, planeNormal.xyz) + planeNormal.w;
}

float distanceToSphere(vec3 spherePosition, float sphereRadius, vec3 position)
{
    return length(position - spherePosition) - sphereRadius;
}

float distanceToTorus(vec3 torusPosition, float radius, float tubeRadius, vec3 position)
{
    vec3 torusToPosition = position - torusPosition;
    vec2 q = vec2(length(torusToPosition.xz)-radius,torusToPosition.y);
    return length(q)-tubeRadius;
}

// -> vec2(distance, materialId)
vec2 distanceToScene(vec3 position) 
{
    float minDistance = 10000;    
    int materialId = -1;
    
    for (int i = 0; i < UScene.numSpheres; i++)
    {
        Sphere sphere = UScene.spheres[i];
        float d = distanceToSphere(sphere.position, sphere.radius, position);
        if (d < minDistance)
        {
            minDistance = d;
            materialId = sphere.materialId;
        }        
    }    

    for (int i = 0; i < UScene.numTori; i++)
    {
        Torus torus = UScene.tori[i];
        float d = distanceToTorus(torus.position, torus.radius, torus.tubeRadius, position);
        if (d < minDistance)
        {
            minDistance = d;
            materialId = torus.materialId;
        }        
    }

    float fractalDistance = distanceToMandelbrot(position);
    if (fractalDistance < minDistance)
    {
        minDistance = fractalDistance;
        materialId = 1;
    }    

    return vec2(minDistance, materialId);
}

// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
vec3 getRayDirection()
{          
    vec2 uv = ((TexCoords * UImageDim + 0.5) - 0.5 * UImageDim) / UImageDim.y;    
    return normalize(vec3(uv, -1));
}

// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting
vec3 getNormal(vec3 position)
{
    vec2 epsilon = vec2(UNormalEpsilon, 0.0);

    return normalize(
        vec3(
            distanceToScene(position + epsilon.xyy).x - distanceToScene(position - epsilon.xyy).x,
            distanceToScene(position + epsilon.yxy).x - distanceToScene(position - epsilon.yxy).x,
            distanceToScene(position + epsilon.yyx).x - distanceToScene(position - epsilon.yyx).x
        )
    );
}

vec3 getPhongColor(vec3 position, vec3 normal, int materialId, vec4 rayDir)
{    
    Material material = UMaterials[materialId];
    // TODO: move to light struct
    vec3 lightColor = vec3(1.0, 0.9, 0.9);
        
    float diffuseContribution = dot(normal, - ULightDirection);
    
    vec3 reflected = reflect(-ULightDirection, normal);
    float specularContribution = pow(max(dot(vec3(rayDir), reflected), 0.0), 32);
    
    return material.ambientColor * lightColor     
        + diffuseContribution * material.diffuseColor * lightColor
        + specularContribution * material.specularColor * lightColor;
}

void main()
{
    vec4 rayDirection = UInvView * vec4(getRayDirection(), 0.0);
    float dist = 0;
    float depth = 0;
    vec3 position;
    vec4 eyePosition = UEyePosition;

    // if (ortho)
    // {
    //     eyePosition += vec4(((TexCoords * UImageDim + 0.5) - 0.5 * UImageDim) / UImageDim.y, 0.0);
    //     rayDirection = vec3(0,0,-1);
    // }

    for(int i = 0; i < maxMarchingSteps; i++)
    {                
        position = vec3(eyePosition + depth * rayDirection);        
        vec2 dist_mat = distanceToScene(position);
        dist = dist_mat.x;
        if (dist < distEpsilon)
        {
            if (showStepCount)
            {
                float steps = i/float(maxMarchingSteps);
                color = vec4(steps, 0.0, 1.0 - steps, 1.0);
            }
            else
            {
                color = vec4(getPhongColor(position, getNormal(position), int(dist_mat.y), rayDirection), 1.0);
            }
            return;
        }                   

        depth += dist;

        if (depth > maxDrawDistance)
        {
            color = vec4(0.1, 0.1, 0.1, 1.0);
            return;
        }

        // this creates a cool looking effect! but no distant fog as it was intended for :)
        // if (depth > maxDrawDistance - 10.0) 
        // {
        //     float factor = depth / maxDrawDistance;
        //     color = vec4(0.1, 0.1, 0.1, 1.0) * factor;
        //     return;
        // }
    }    
    color = vec4(0.1, 0.1, 0.1, 1.0);
}