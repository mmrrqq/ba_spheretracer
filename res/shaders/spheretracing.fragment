#version 430 core
struct AreaLight
{
    vec4 position;
    vec4 color;
    float size;
};

struct Sphere 
{
    vec4 position;
    float radius;    
    int materialId;
};

struct Torus
{
    vec4 position;
    float radius;
    float tubeRadius;
    int materialId;
};

struct Material
{
    vec4 ambientColor;    
    vec4 diffuseColor;
    vec4 specularColor;
    float shininess;
};

struct SDField
{
    sampler3D field;
    vec3 position;
    vec3 dimensions;
};

uniform float UFovY;
uniform vec2 UImageDim;
uniform float UNormalEpsilon;
uniform vec3 ULightDirection;
uniform vec4 UEyePosition;
uniform int UMarchingSteps;
uniform float UMaxDrawDistance;
uniform bool UUseDepthTexture;
uniform bool UWriteColor;
uniform bool USmooth;
uniform bool UDrawShadows;

uniform sampler2D UDepthTexture;
uniform mat4 UInvView;
uniform SDField USDField;

layout(std430, binding = 3) readonly buffer inSpheres
{
  Sphere spheres[];
};
layout(std430, binding = 4) readonly buffer inTori
{
  Torus tori[];
};
layout(std430, binding = 5) readonly buffer inLights
{
    AreaLight areaLights[];
};
layout(std430, binding = 6) readonly buffer inMaterials
{
    Material materials[];
};

in vec2 TexCoords;
out vec4 color;

// credit iquilez
float distanceToMandelbrot2(vec3 pos)
{
    vec3 w = pos;
    float m = dot(w,w);

    vec4 trap = vec4(abs(w),m);
	float dz = 1.0;
    
    
	for( int i=0; i<4; i++ )
    {
        float m2 = m*m;
        float m4 = m2*m2;
		dz = 8.0*sqrt(m4*m2*m)*dz + 1.0;

        float x = w.x; float x2 = x*x; float x4 = x2*x2;
        float y = w.y; float y2 = y*y; float y4 = y2*y2;
        float z = w.z; float z2 = z*z; float z4 = z2*z2;

        float k3 = x2 + z2;
        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );
        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;
        float k4 = x2 - y2 + z2;

        w.x = pos.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;
        w.y = pos.y + -16.0*y2*k3*k4*k4 + k1*k1;
        w.z = pos.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2; 
        
        trap = min( trap, vec4(abs(w),m) );

        m = dot(w,w);
		if( m > 256.0 )
            break;
    }    

    return 0.25*log(m)*sqrt(m)/dz;
}

float distanceToBox(vec3 p, vec3 pBox, vec3 dimensions)
{
  vec3 q = abs(p - pBox) - dimensions;
  return length(max(q, 0.0)) 
    + min(max(q.x, max(q.y, q.z)), 0.0);
}

float distanceToGroundPlane(vec3 planePosition, vec4 planeNormal, vec3 position)
{
	return dot(position - planePosition, planeNormal.xyz) + planeNormal.w;
}

float distanceToSphere(vec3 spherePosition, float sphereRadius, vec3 position)
{
    return length(position - spherePosition) - sphereRadius;
}

float distanceToTorus(vec3 torusPosition, float radius, float tubeRadius, vec3 position)
{
    vec3 torusToPosition = position - torusPosition;
    vec2 q = vec2(length(torusToPosition.xz) - radius, torusToPosition.y);
    return length(q) - tubeRadius;
}

float distanceToField(SDField field, vec3 position)
{
    float distanceBox = distanceToBox(position, field.position, field.dimensions);    

    if (distanceBox < 0.0)
    {
        vec3 voxelCoords = position - field.position;        

        ivec3 texSize = textureSize(field.field, 0);
        
        voxelCoords /= field.dimensions;                
        voxelCoords = .5 + 0.5 * voxelCoords;
        
        return (texture(field.field, voxelCoords).x / texSize.x) * field.dimensions.x;
    }    
    return distanceBox + 0.1 * field.dimensions.x;
}

vec4 hardMin(vec4 dist1, vec4 dist2)
{
    return dist1.x < dist2.x ? dist1 : dist2;
}

vec2 hardMin(vec2 dist1, vec2 dist2)
{
    return dist1.x < dist2.x ? dist1 : dist2;    
}

vec4 smoothColorMin(vec4 distMatColor, vec2 distMat, float k)
{
    vec4 minVec = mix(distMatColor, vec4(distMat, -1, -1), step(distMat.x, distMatColor.x));
    vec4 maxVec = mix(distMatColor, vec4(distMat, -1, -1), step(distMatColor.x, distMat.x));

    vec3 minDiffCol = minVec.z < 0 ? materials[int(minVec.y)].diffuseColor.xyz : minVec.yzw;
    vec3 maxDiffCol = maxVec.z < 0 ? materials[int(maxVec.y)].diffuseColor.xyz : maxVec.yzw;

    float h = max(k - abs(distMat.x - distMatColor.x), 0.0)/k;
    float dist = min(distMat.x, distMatColor.x) - h*h*k*(1.0/4.0);
    return vec4(dist, mix(minDiffCol, maxDiffCol, h/2.0));
}

vec2 smoothMin(vec2 dist1, vec2 dist2, float k)
{
    float h = max(k - abs(dist1.x - dist2.x), 0.0)/k;
    float dist = min(dist1.x, dist2.x) - h*h*k*(1.0/4.0);
    return vec2(dist, dist1.y);
}

float smoothMin(float dist1, float dist2, float k)
{
    float h = max(k - abs(dist1 - dist2), 0.0)/k;
    return min(dist1, dist2) - h*h*k*(1.0/4.0);
}

float minFn(float prevDist, float dist)
{
    if (USmooth)
        return smoothMin(prevDist, dist, 0.5);
    return min(prevDist, dist);
}

float distanceToScene(vec3 position) 
{    
    float res = 1000;
    
    for (int i = 0; i < spheres.length(); i++)
    {
        Sphere sphere = spheres[i];
        res = minFn(res, distanceToSphere(sphere.position.xyz, sphere.radius, position));                
    }    

    for (int i = 0; i < tori.length(); i++)
    {
        Torus torus = tori[i];        
        res = minFn(res, distanceToTorus(torus.position.xyz, torus.radius, torus.tubeRadius, position));             
    }

    vec3 rep = vec3(10.0, 1000.0, 10.0);
    
    // res = minFn(res, distanceToField(USDField, mod(position + 0.5 * rep, rep) - 0.5 * rep));
    res = minFn(res, distanceToField(USDField, position));

    res = minFn(res, distanceToGroundPlane(vec3(0.0, -0.5, 0.0), vec4(0.0, 1.0, 0.0, 0.0), position));

    return res;
}

vec4 minColorFn(vec4 prevDist, float dist, int materialId)
{
    if (USmooth)
        return smoothColorMin(prevDist, vec2(dist, materialId), 0.5);
    return hardMin(prevDist, vec4(dist, materialId, -1, -1));
}

// yzw are either the diffuse color value or y is the materialID and others are -1
vec4 distanceToSceneColor(vec3 position)
{
    vec4 res = vec4(1000, -1, -1, -1);

    for (int i = 0; i < spheres.length(); i++)
    {
        Sphere sphere = spheres[i];
        float d = distanceToSphere(sphere.position.xyz, sphere.radius, position);        
        res = minColorFn(res, d, sphere.materialId);
    }

    for (int i = 0; i < tori.length(); i++)
    {
        Torus torus = tori[i];
        float d = distanceToTorus(torus.position.xyz, torus.radius, torus.tubeRadius, position);
        res = minColorFn(res, d, torus.materialId);             
    }
    // vec3 rep = vec3(10.0, 1000.0, 10.0);

    // float fieldDistance = distanceToField(USDField, mod(position + 0.5 * rep, rep) - 0.5 * rep);    
    float fieldDistance = distanceToField(USDField, position);    
    res = minColorFn(res, fieldDistance, 0);

    float planeDistance = distanceToGroundPlane(vec3(0.0, -0.5, 0.0), vec4(0.0, 1.0, 0.0, 0.0), position);        
    res = minColorFn(res, planeDistance, 0);

    return res;
}

// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
vec3 getRayDir()
{
    vec2 uv = tan(radians(UFovY)/2) * ((TexCoords * UImageDim + 0.5) - 0.5 * UImageDim) / UImageDim.y;        
    return  normalize(vec3(uv, -1));                
}

vec3 getNormal(vec3 position)
{
    vec2 epsilon = vec2(UNormalEpsilon, 0.0);    

    return normalize(
        vec3(
            distanceToScene(position + epsilon.xyy) - distanceToScene(position - epsilon.xyy),
            distanceToScene(position + epsilon.yxy) - distanceToScene(position - epsilon.yxy),
            distanceToScene(position + epsilon.yyx) - distanceToScene(position - epsilon.yyx)
        )
    );
}

float getAreaLightShadowFactor(vec3 position, vec3 lightPosition, float lightSize)
{
    vec3 lightVec = lightPosition - position;
    vec3 rayDir = normalize(lightVec); 
    float maxDist = length(lightVec);    
    float dist = 0.0, minDist = 1.0, depth = 0.001;        
    
    for(int i = 0; i < UMarchingSteps; i++)
    {                        
        dist = distanceToScene(position + depth * rayDir);          
        minDist = min(0.5 + 0.5 * dist / (lightSize*depth), minDist);                                      
        
        depth += clamp(dist, 0.05, 10.0);
        if (depth > maxDist || minDist < 0.001)
            break;
    }        
    return smoothstep(0.0, 1.0, minDist);     
}

vec3 getPhongColor(vec3 position, vec3 normal, vec3 matCol, vec4 rayDir)
{   
    Material material;
    if (matCol.y < 0)     
        material = materials[int(matCol.x)];    
    else
    {        
        material.diffuseColor = vec4(matCol, 1);    
        material.specularColor = vec4(matCol, 1) * 0.8;    
        material.ambientColor = vec4(matCol, 1) * 0.2;  
        material.shininess = 32.0;
    }
    
    vec3 phongColor = vec3(0.0, 0.0, 0.0);    
    
    for (int i = 0; i < areaLights.length(); i++)
    {
        AreaLight light = areaLights[i];
        phongColor += (material.ambientColor * light.color).xyz;
        vec3 lightDir = normalize(light.position.xyz - position);
        float diffuseContribution = max(0.0, dot(normal, lightDir));            
        float shadow = 1.0;
        if (UDrawShadows)
            shadow = getAreaLightShadowFactor(position, light.position.xyz, light.size);        

        if (shadow < 0.01)    
            continue;        
            
        vec3 reflected = reflect(lightDir, normal);
        float specularContribution = pow(max(dot(vec3(rayDir), reflected), 0.0), material.shininess);
                
        phongColor += shadow * (diffuseContribution * material.diffuseColor * light.color
            + specularContribution * material.specularColor * light.color).xyz;

    }        
    
    return phongColor;        
}

vec3 applyFog(vec3 color, float depth)
{
    //https://iquilezles.org/www/articles/fog/fog.htm
    vec3 fogColor = vec3(0.5,0.6,0.7);
    return mix(color, fogColor, 1.0 - exp(-depth * 0.05)) 
        * exp(-0.00005*depth*depth*depth);
}

vec4 traceDepth(vec4 rayDirection, float depth)
{
    vec3 position;        

    float coneRadiusCoeff = 2 * tan(radians(UFovY / 2)) / UImageDim.y;
    // float coneRadiusCoeff = sqrt(2) / length(UImageDim);

    for(int i = 0; i < UMarchingSteps; i++)
    {                
        position = vec3(UEyePosition + depth * rayDirection);
        float dist = distanceToScene(position);        
        float coneRadius = depth * coneRadiusCoeff;   

        if (dist < coneRadius)       
        {
            if (UWriteColor)
                return vec4(position, depth);
            return vec4(position, depth - coneRadius);                    
        }         

        depth += dist;

        if (depth > UMaxDrawDistance)
            break;
    }
    return vec4(position, depth);
}

void setColor(vec4 rayDirection, vec3 position, float depth)
{
    if (depth > UMaxDrawDistance)
    {                         
        color = vec4(applyFog(vec3(0.1, 0.1, 0.1), UMaxDrawDistance), 1.0);
        return;
    }    

    vec4 distMat = distanceToSceneColor(position);        

    vec3 phongColor = getPhongColor(position, getNormal(position), distMat.yzw, rayDirection);
    color = vec4(        
        applyFog(phongColor, depth), 
        1.0
    ); 
}

void main()
{
    vec3 cameraRayDir = getRayDir();
    vec4 rayDirection = UInvView * vec4(cameraRayDir, 0.0);        

    float depth = UUseDepthTexture 
        ? texture(UDepthTexture, TexCoords.xy).r * UMaxDrawDistance
        : 0.0;

    vec4 posAndDepth = traceDepth(rayDirection, depth);
    depth = posAndDepth.w;
    vec3 position = posAndDepth.xyz;

    if (UWriteColor)
        setColor(rayDirection, position, depth);

    gl_FragDepth = depth / UMaxDrawDistance;       
}