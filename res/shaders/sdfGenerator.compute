#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(rgba32f, binding = 0) uniform image2D inTex;
layout(rgba32f, binding = 1) uniform image3D outTex;

struct Triangle
{
  vec3 p1;
  vec3 p2;
  vec3 p3;
};

float dot2( in vec3 v ) { return dot(v,v); }

float udTriangle( vec3 p, Triangle triangle)
{
  vec3 ba = triangle.p2 - triangle.p1; 
  vec3 cb = triangle.p3 - triangle.p2; 
  vec3 ac = triangle.p1 - triangle.p3; 

  vec3 pa = p - triangle.p1;
  vec3 pb = p - triangle.p2;
  vec3 pc = p - triangle.p3;

  vec3 nor = cross(ba, ac);

  return sqrt(
    (sign(dot(cross(ba,nor),pa)) +
      sign(dot(cross(cb,nor),pb)) +
      sign(dot(cross(ac,nor),pc))<2.0)
      ? min(
        min(
          dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),
          dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)
        ),
        dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc))
      : dot(nor,pa)*dot(nor,pa)/dot2(nor)
  );
}

void main() {  
  // get index in global work group i.e x,y position
  uvec3 voxelCoords = uvec3(gl_GlobalInvocationID.xyz);

  // //get distance to object
  // float depth = 1.0;  
  // for (int i = 0; i < imageSize(inTex).x; i += 3)
  // {
  //   Triangle triangle;
  //   triangle.p1 = imageLoad(inTex, ivec2(i, 0)).xyz;
  //   triangle.p2 = imageLoad(inTex, ivec2(i + 1, 0)).xyz;
  //   triangle.p3 = imageLoad(inTex, ivec2(i + 2, 0)).xyz;
        
  //   float tempDepth = udTriangle(voxelCoords, triangle);
  //   if (tempDepth < depth)
  //     depth = tempDepth;
  // }  

  imageStore(outTex, ivec3(voxelCoords), vec4(1.0, 1.0, 1.0, 1.0));
  // output to a specific pixel in the image
  // imageStore(outTex, ivec3(voxelCoords), vec4(voxelCoords.x / gl_NumWorkGroups.x, voxelCoords.y / gl_NumWorkGroups.y, voxelCoords.z / gl_NumWorkGroups.z, 1.0));
}