#version 430

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D inTex;
layout(rgba32f, binding = 1) uniform image3D outTex;

struct Triangle
{
  vec3 p1;
  vec3 p2;
  vec3 p3;
};

float dot2( in vec3 v ) { return dot(v,v); }

float udTriangle( vec3 p, Triangle triangle)
{
  vec3 ba = triangle.p2 - triangle.p1; 
  vec3 cb = triangle.p3 - triangle.p2; 
  vec3 ac = triangle.p1 - triangle.p3; 

  vec3 pa = p - triangle.p1;
  vec3 pb = p - triangle.p2;
  vec3 pc = p - triangle.p3;

  vec3 nor = cross(ba, ac);

  return sqrt(
    (sign(dot(cross(ba,nor),pa)) +
      sign(dot(cross(cb,nor),pb)) +
      sign(dot(cross(ac,nor),pc))<2.0)
      ? min(
        min(
          dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),
          dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)
        ),
        dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc))
      : dot(nor,pa)*dot(nor,pa)/dot2(nor)
  );
}

void main() {  
  // get index in global work group i.e x,y position
  ivec3 voxelCoords = ivec3(gl_GlobalInvocationID.xyz);

  //get distance to object
  float depth = 1000.0;  
  for (int i = 0; i < imageSize(inTex).x; i += 3)
  {
    Triangle triangle;
    triangle.p1 = imageLoad(inTex, ivec2(i, 0)).xyz;
    triangle.p2 = imageLoad(inTex, ivec2(i + 1, 0)).xyz;
    triangle.p3 = imageLoad(inTex, ivec2(i + 2, 0)).xyz;
        
    float tempDepth = udTriangle(voxelCoords, triangle);
    if (tempDepth < depth)
      depth = tempDepth;
  }  
    
  // output to a specific pixel in the image
  imageStore(outTex, ivec3(voxelCoords), vec4(depth, depth, depth, 1.0));
}